# GC（垃圾回收） 

1. Go v1.3及之前采用的GC算法是标记—清除算法，在GC期间，需要STW。
2. Go v1.5及v1.7之间采用了三色标记—清除算法+插入写屏障，其中插入写屏障机制只在堆内存中生效。但在标记过程中，最后需要对栈进行STW
3. Go v1.8及之后推出了三色标记—清除算法+插入写屏障+删除写屏障，屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率

## 三色标记—清除算法
步骤：
1. 刚开始所有的对象都是白色对象，Root Set根节点中的对象都是黑色对象；
2. 将与黑色对象直接相连的白色对象标记为灰色对象，并将灰色对象放入灰色对象集合中
3. 从灰色对象集合中选中一个灰色对象标记为黑色，并将黑色对象放入黑色对象集合中
4. 重复第2步和第3步

其中
1. Root Set：
   1. 全局变量：全局变量的生命周期与进程的生命周期相同，在编译期间就能确定；
   2. 执行栈：栈上的变量和引用堆上的内存指针
2. 颜色的含义：
   1. 白色对象 ：内存垃圾，内存将被回收
   2. 灰色对象：指向白色对象的对象，是一种不稳定的状态
   3. 黑色对象：不指向白色对象的对象和从跟对象可达的对象
3. 上述的三色标记—清除算法如果没有STW是有问题的，例如同时满足下面的两个条件
   1. 条件一：黑色对象引用了白色对象
   2. 条件二：灰色对象在可达链上失去了对白色对象的引用
4. 只要破坏了上述两个条件之一，就可以不进行STW
   1. 破坏条件一：黑色对象不准引用白色对象
   2. 破坏条件二:黑色对象可以引用白色对象，但是白色对象上游必须有灰色对象
5. 插入写屏障：当对象A引用了对象B，将对象B标记为灰色。这对应于破坏条件一，强三色不变式
6. 删除写屏障：当对象A失去了对象B的引用，如果对象B是白色，则将对象B变为灰色。这是对应破坏条件二，弱三色不变式

## V1.5 三色标记—清除 + 插入写屏障
插入写屏障仅仅适合在堆区，不在栈区，因为这是因为go在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万goroutine的栈都进行屏障保护自然会有性能问题。所以，执行完之后需要STW，对栈区进行重新三色标记—删除。

## V1.8 三色标记—清除 + 插入写屏障 + 删除写屏障

插入写屏障和删除写屏障仅仅运用在堆上，为了程序运行效率栈上不使用任何写屏障。同时在GC开始时，需要将栈上所有的可达对象标记为黑色，GC期间栈上创建的任何对象均为黑色。

插入写屏障：当堆上对象A引用了堆上对象B，将对象B标记为灰色；注意，如果栈上对象A引用了对象B，那么B仍然是白色。

删除写屏障：当堆上对象A失去了堆上对象B的引用，如果对象B是白色，则将对象B变为灰色。

整个过程不需要STW！


## GC触发条件
自动垃圾回收的触发条件有两个：

- 超过内存大小阈值

- 达到定时时间

阈值是由一个gcpercent的变量控制的,当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。
如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。
