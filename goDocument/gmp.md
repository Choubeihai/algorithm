## GPM与CSP

1. **全局队列**（Global Queue）：存放等待运行的G。
2. **P的本地队列**：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3. **P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有`GOMAXPROCS`(可配置)个。
4. **M**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。M的数量：go程序启动时，会设置M的最大数量，默认10000。一个M阻塞了，会创建另一个M。
4. 普通Go程的默认栈大小是2KB，最大是1GB
4. G0这个go程默认栈大小是固定的8MB，不能扩容和缩容。

**Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行**。

1. M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。
2. P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。
3. M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。

## goroutine的调度策略

1. 复用线程，避免频繁创建和销毁线程
   1. work stealing机制：当M无可运行的G时，尝试从其它M绑定的P偷取G，而不是销毁M对应的线程。
   2. hand off机制：当M因为G进行系统调用阻塞时，M就会释放P，把P转移给其他空闲的线程执行。
2. 并行处理：`GOMAXPROCS`设置P的数量，最多有`GOMAXPROCS`个线程分布在多个CPU上同时运行。`GOMAXPROCS`也限制了并发的程度，比如`GOMAXPROCS = 核数/2`，则最多利用了一半的CPU核进行并行。设置`GOMAXPROCS`更大一些会提高I/O的吞吐率，因此对于IO密集型的服务，应该将GOMAXPROCS设置的大一些。
3. 抢占式调度：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。
4. 全局G队列：当P的本地队列为空时，M先从全局队列拿G放到P的本地队列，再从其它P窃取

## g0调度多场景分析

1. 场景一：P拥有G1，M1获取P后开始运行G1，G1使用`go func()`创建了G2，为了局部性G2优先加入到P1的本地队列。

   <img src="./assets/gmp/1650776522560-a33b69e2-2842-4132-8cbe-f2bad017bc7e.png" alt="26-gmp场景1.png" style="zoom:33%;" />

2. 场景二：G1运行完成后(函数：`goexit`)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：`schedule`）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：`execute`)。实现了线程M1的复用。

   <img src="./assets/gmp/1650776536644-c6fba007-d952-4a22-8939-ca1a898a5c3c.png" alt="img" style="zoom:33%;" />

3. 场景三：假设每个P的本地队列只能存4个G。G2要创建了4个G，前4个G（G3, G4, G5, G6）已经加入p1的本地队列，p1本地队列满了。

   <img src="./assets/gmp/1650776549767-57ceac17-5504-46ac-af56-0dba59359e8b.png" alt="img" style="zoom:33%;" />

4. 场景四：G2在创建G7的时候，发现P1的本地队列已满，需要执行**负载均衡**(把P1中本地队列中前一半的G，还有新创建G**转移**到全局队列)，这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。

   注意：实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，把新G加入到全局队列）

   <img src="./assets/gmp/1650776570176-d9d5abd4-3a48-461c-a43c-6ef504c4038f.png" alt="29-gmp场景4.png" style="zoom:33%;" />

   5. 场景五：G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。

      <img src="./assets/gmp/1650776584395-dfb9c26b-b0a8-4c17-b46e-649302df87d5.png" alt="30-gmp场景5.png" style="zoom:33%;" />

   6. 场景六：当创建一个G时，创建完成G后将G放入本地队列，父G会尝试唤醒一个空闲M组合去执行，M被唤醒后与一个P绑定，找不到P就接着睡眠。假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程**（没有G但为运行状态的线程，不断寻找G）**

      <img src="./assets/gmp/1650776600276-58bdcec4-00e6-4f24-89c8-e4f01fd1d9fb.png" alt="img" style="zoom:33%;" />

   7. 场景六：M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：`findrunnable()`）。M2从全局队列取的G数量符合下面的公式：
      $$
      n =  min(全局队列中g的个数 / p的个数 +  1, 全局队列中g的个数 / 2 )
      $$
      至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是**从全局队列到P本地队列的负载均衡**。

      <img src="./assets/gmp/1650776688586-9207de08-5203-403f-8857-42942e84dcb1.jpeg" alt="img" style="zoom:33%;" />

      7. 场景七：偷取G的情况。假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了。从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。

         <img src="./assets/gmp/1650777780659-cef000df-3d46-4fd5-b0ed-3dc466bf1cd2-20220608211930573.png" alt="img" style="zoom:33%;" />

         8. 场景八：自旋线程的最大限制。G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于**自旋状态**，它们不断寻找goroutine。为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU.  为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们**希望当有新goroutine创建时，立刻能有M运行它**，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有`GOMAXPROCS`个自旋的线程(当前例子中的`GOMAXPROCS`=4，所以一共4个P)，多余的没事做线程会让他们休眠。

            <img src="./assets/gmp/1650777794441-a7ed7fc2-e495-4022-a3b6-581930e5acd0.png" alt="img" style="zoom:33%;" />

            10. 场景十：当G发生阻塞或系统调用。假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M>=P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了**阻塞的系统调用**，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。

                <img src="./assets/gmp/1650777810926-ca4030f3-f29a-4211-8722-677b229be440.png" alt="img" style="zoom:33%;" />

            11. 场景十一：G发生非阻塞系统调用。M2和P2会解绑，但M2会记住P2，然后G8和M2进入**系统调用**状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。

                <img src="./assets/gmp/1650777823944-25f0ea1a-3431-457e-b4cf-342654a953b6.png" alt="img" style="zoom:33%;" />

   

## M0和G0

1. M0是启动Go程序后的创建的第一个线程，然后创建M0的G0，再创建main goroutine，为main goroutine寻找一个P，将M0与P绑定，G0调用main goroutine，M0执行main goroutine，时间片到了，将main goroutine放回。
2. G0是每创建一个M后，都会自动创建的第一个G，作用相当于内核，G0仅用于负责调度其他的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度和系统调用时会使用G0的栈空间。 全局变量的G0是M0的G0。

详细过程：

1. runtime创建最初的线程m0和goroutine g0，并把2者关联。
2. 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。
3. main函数是`main.main`，`runtime`中也有1个main函数——`runtime.main`，代码经过编译后，`runtime.main`会调用`main.main`，程序启动时会为`runtime.main`创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。
4. 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。
5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境
6. M运行G
7. G退出，再次回到M获取可运行的G，这样重复下去，直到`main.main`退出，`runtime.main`执行Defer和Panic处理，或调用`runtime.exit`退出程序。

## sysmon

sysmon是我们的保洁阿姨，它是一个M，又叫监控线程，不需要P就可以独立运行，每20us~10ms会被唤醒一次出来打扫卫生，主要工作就是回收垃圾、回收长时间系统调度阻塞的P、向长时间运行的G发出抢占调度等等。

